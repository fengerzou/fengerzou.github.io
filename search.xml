<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>WebSocket的学习以及websocketd的使用</title>
      <link href="/2018/12/20/WebSocket%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8Awebsocketd%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/12/20/WebSocket%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8Awebsocketd%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>WebSocket</strong></p><p><em>websocket简介</em><br>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p><p>其它特点包括：</p><ul><li>建立在 TCP 协议之上，服务器端的实现比较容易。</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li><li>数据格式比较轻量，性能开销小，通信高效。</li><li>可以发送文本，也可以发送二进制数据。</li><li>没有同源限制，客户端可以与任意服务器通信。</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure><a id="more"></a><p><em>WebSocket客户端的API</em><br>构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WebSocket(&apos;ws://localhost:8080&apos;);</span><br></pre></td></tr></table></figure></p><p>webSocket.readyState</p><pre><code>+ CONNECTING：值为0，表示正在连接。+ OPEN：值为1，表示连接成功，可以通信了。+ CLOSING：值为2，表示连接正在关闭。+ CLOSED：值为3，表示连接已经关闭，或者打开连接失败。    </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">switch (ws.readyState) &#123;</span><br><span class="line">  case WebSocket.CONNECTING:</span><br><span class="line">    // do something</span><br><span class="line">    break;</span><br><span class="line">  case WebSocket.OPEN:</span><br><span class="line">    // do something</span><br><span class="line">    break;</span><br><span class="line">  case WebSocket.CLOSING:</span><br><span class="line">    // do something</span><br><span class="line">    break;</span><br><span class="line">  case WebSocket.CLOSED:</span><br><span class="line">    // do something</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    // this never happens</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webSocket.onopen<br>实例对象的onopen属性，用于指定连接成功后的回调函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>webSocket.onclose<br>实例对象的onclose属性，用于指定连接关闭后的回调函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>webSocket.onmessage<br>实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> event.data === <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received data string"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(event.data <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = event.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Received arraybuffer"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/ 收到的是 blob 数据</span><br><span class="line">ws.binaryType = <span class="string">"blob"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 ArrayBuffer 数据</span></span><br><span class="line">ws.binaryType = <span class="string">"arraybuffer"</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>webSocket.send()<br>实例对象的send()方法用于向服务器发送数据。<br>发送文本的例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.send(<span class="string">'your message'</span>);</span><br></pre></td></tr></table></figure></p><p>发送 Blob 对象的例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">'input[type="file"]'</span>)</span><br><span class="line">  .files[<span class="number">0</span>];</span><br><span class="line">ws.send(file);</span><br></pre></td></tr></table></figure></p><p>发送 ArrayBuffer 对象的例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) &#123;</span><br><span class="line">  binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br></pre></td></tr></table></figure></p><p>webSocket.bufferedAmount<br>实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10000000</span>);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>webSocket.onerror<br>实例对象的onerror属性，用于指定报错时的回调函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.addEventListener(<span class="string">"error"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>websocketd</strong></p><p>websocketd是WebSocket守护进程，它负责处理WebSocket连接，启动您的程序来处理WebSockets，并在程序和Web浏览器之间传递消息。后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。</p><p><em>安装</em><br>在官网<a href="http://websocketd.com/下载Linux64-bit版本，解压后生成**websocketd**这个文件，复制该文件到/usr/bin目录下，修改环境变量" target="_blank" rel="noopener">http://websocketd.com/下载Linux64-bit版本，解压后生成**websocketd**这个文件，复制该文件到/usr/bin目录下，修改环境变量</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unzip -d /home/xxx/websocketd websocketd-0.2.12-linux_amd64.zip</span><br><span class="line"></span><br><span class="line">cd /home/xxx/websocketd</span><br><span class="line"></span><br><span class="line">sudo cp websocketd /usr/bin/websocketd</span><br><span class="line"></span><br><span class="line">sudo vim /etc/profile</span><br><span class="line"></span><br><span class="line">export  PATH=$PATH:/usr/bin/websocketd</span><br><span class="line"></span><br><span class="line">source profile</span><br></pre></td></tr></table></figure></p><p>输入websocketd –version出现版本信息验证安装成功</p><p><em>测试</em><br>测试脚本：count.sh<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> ((COUNT = <span class="number">1</span>; COUNT &lt;= <span class="number">10</span>; COUNT++)); <span class="keyword">do</span></span><br><span class="line">  echo <span class="variable">$COUNT</span></span><br><span class="line">  sleep <span class="number">1</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>给count.sh赋执行权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./count.sh</span><br></pre></td></tr></table></figure></p><p>启动websocketd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">websocketd --port=63800 ./count.sh</span><br></pre></td></tr></table></figure></p><p>上面的命令会启动一个 WebSocket 服务器，端口是63800。每当客户端连接这个服务器，就会执行count.sh脚本，并将它的输出推送给客户端。<br>打开chrome浏览器的console，输入以下代码测试<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://192.168.18.12:63800/'</span>);</span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'CONNECT'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'DISCONNECT'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'MESSAGE: '</span> + event.data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《深入理解ES6》笔记（三）</title>
      <link href="/2018/10/26/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2018/10/26/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>第5章 解构：使数据访问更便捷</strong></p><p><em>对象解构</em></p><p>对象解构的语法形式是在一个赋值操作符左边放置一个对象字面量，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">type: <span class="string">"Identifier"</span>,</span><br><span class="line">name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; type, name &#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(type); <span class="comment">//Identifier</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//foo</span></span><br></pre></td></tr></table></figure></p><p>在这段代码中，node.type的值被存储在名为type的变量中；node.name的值被存储在名为name的变量中。如果使用var、let或const解构声明变量，则必须要提供初始化程序（也就是等号右侧的值）。</p><p><em>解构赋值</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">type: <span class="string">"Identifier"</span>,</span><br><span class="line">name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> type = <span class="string">"Nicholas"</span>,</span><br><span class="line">name = <span class="number">5</span>;</span><br><span class="line"> (&#123; type, name&#125; = node);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(type); <span class="comment">//Identifier</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//foo</span></span><br></pre></td></tr></table></figure><p>在这个示例中，声明变量type和name时初始化了一个值，在后面几行中，通过解构赋值的方法，从node对象读取相应的值重新为这两个变量赋值。请注意，一定要用一对小括号包裹解构赋值语句，JavaScript引擎将一对开放的花括号视为一个代码块，而语法规定，代码块语句不允许出现在赋值语句左侧，添加小括号后可以将块语句转化为一个表达式，从而实现整个解构赋值的过程。解构赋值表达式的值与表达式右侧（也就是=右侧）的值相等，如此一来，在任何可以使用值的地方你都可以使用解构赋值表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">type: <span class="string">"Identifier"</span>,</span><br><span class="line">name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> type = <span class="string">"Nicholas"</span>,</span><br><span class="line">name = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputInfo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value === node);   <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> outputInfo(&#123; type, name&#125; = node);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(type); <span class="comment">//Identifier</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//foo</span></span><br></pre></td></tr></table></figure><p>解构赋值表达式（也就是=右侧的表达式）如果为null或undefined会导致程序抛出错误。</p><a id="more"></a><p><em>默认值</em></p><p>使用解构赋值表达式时，如果指定的局部变量名称在对象中不存在，那么这个局部变量会被赋值为undefined：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">type: <span class="string">"Identifier"</span>,</span><br><span class="line">name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; type, name, value &#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(type); <span class="comment">//Identifier</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//foo</span></span><br></pre></td></tr></table></figure><p>当指定的属性不存在时，可以随意定义一个默认值，在属性名称后添加一个等号和相应的默认值即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">type: <span class="string">"Identifier"</span>,</span><br><span class="line">name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; type, name, value = <span class="literal">true</span> &#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(type); <span class="comment">//Identifier</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//foo</span></span><br></pre></td></tr></table></figure><p><em>为非同名局部变量赋值</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">type: <span class="string">"Identifier"</span>,</span><br><span class="line">name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: lcoalName &#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(localType); <span class="comment">//Identifier</span></span><br><span class="line"><span class="built_in">console</span>.log(lcoalName); <span class="comment">//foo</span></span><br></pre></td></tr></table></figure><p>type:localType语法的含义是读取名为type的属性并将其值存储在变量localType中，这种语法实际上与传统对象字面量相悖，原来的语法名称在冒号左边，值在右边；现在变量名称在冒号右边，而需要读取的位置（对象的属性名）在左边。当使用其他变量名进行赋值时也可以添加默认值，只需要在变量名后添加等号和默认值即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">type: <span class="string">"Identifier"</span>,</span><br><span class="line"><span class="comment">// name: "foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: lcoalName = <span class="string">"bar"</span> &#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(localType); <span class="comment">//Identifier</span></span><br><span class="line"><span class="built_in">console</span>.log(lcoalName); <span class="comment">//bar</span></span><br></pre></td></tr></table></figure><p><em>嵌套对象解构</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">type: <span class="string">"Identifier"</span>,</span><br><span class="line">name: <span class="string">"foo"</span>,</span><br><span class="line">loc: &#123;</span><br><span class="line">start: &#123;</span><br><span class="line">line: <span class="number">1</span>,</span><br><span class="line">column: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">end: &#123;</span><br><span class="line">line: <span class="number">1</span>,</span><br><span class="line">column: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123; start &#125;&#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(start.line); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(start.column); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>在这个示例中，我们在解构模式中使用了花括号，其含义为在找到node对象中loc属性后，应当深入一层继续查找start属性。上面的解构示例中，所有冒号前的标识符都代表在对象中的检索位置，其右侧为被赋值的变量名。</p><p><em>数组结构</em></p><p>与对象解构的语法相比，数组结构就简单多了，它使用的是数组字面量，且解构操作全部在数组内完成，而不是像对象字面量语法一样使用对象的命名属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>,<span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> [ firstColor, secondColor ] = colors;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">//red</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">//green</span></span><br></pre></td></tr></table></figure><p>在数组解构语法中，我们通过值在数组中的位置选取，且可以将其存储在任意变量中，未显式声明的元素都会直接被忽略。在这个过程中，数组本身不会发生任何变化。在解构模式中，也可以直接省略元素，只为感兴趣的元素提供变量名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>,<span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">let</span> [ , , thirdColor] = colors;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(thirdColor); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure><p>数组解构语法还有一个独特的用例：交换两个变量值，无需引入第三个临时变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[ a, b ] = [ b, a ];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>数组的解构赋值与默认值参考对象字面量的解构赋值和默认值。</p><p><em>嵌套数组解构</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, [ <span class="string">"green"</span>, <span class="string">"lightgreen"</span> ], <span class="string">"blue"</span> ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ firstColor, [ secondColor ] ] = colors;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">//red</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">//green</span></span><br></pre></td></tr></table></figure><p><em>不定元素</em></p><p>在数组中，可以通过…语法将数组中的其余元素赋值给一个特定的变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ firstColor, ...restColors] = colors;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">//red</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors.length); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors[<span class="number">0</span>]); <span class="comment">//green</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors[<span class="number">1</span>]); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure><p>数组colors中的第一个元素被赋值给了firstColor，其余的元素被赋值给restColors数组，所以restColors中包含两个元素。不定元素语法有助于从数组中提取特定元素并保证其余元素可用。不定元素必须为最后一个条目。可以利用不定元素的语法来实现复制一个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ ...clonedColors] = colors;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(clonedColors); <span class="comment">//["red", "green", "blue"]</span></span><br></pre></td></tr></table></figure><p><em>混合结构</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">type : <span class="string">"Identifier"</span>,</span><br><span class="line">name: <span class="string">"foo"</span>,</span><br><span class="line">loc: &#123;</span><br><span class="line">start: &#123;</span><br><span class="line">line: <span class="number">1</span>,</span><br><span class="line">column: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">end: &#123;</span><br><span class="line">line: <span class="number">1</span>,</span><br><span class="line">column: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">range: [<span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">loc: &#123; start &#125;,</span><br><span class="line">range: [ startIndex ]</span><br><span class="line">&#125; = node;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(start.line); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(start.column); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(startIndex); <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>这种方法极为有效，尤其是当你从JSON配置中提取信息时，不再需要遍历整个结构了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《深入理解ES6》笔记（二）</title>
      <link href="/2018/10/25/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/10/25/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>第4章 扩展对象的功能性</strong></p><p><em>对象字面量语法扩展</em></p><p>在ECMAScript5及更早版本中，对象字面量只是简单的键值对集合，这意味着初始化属性值时会有一些重复，举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">name: name,</span><br><span class="line">age: age</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码中的createPerson()函数创建了一个对象，其属性名和函数的参数相同，在返回的结果中，name和age分别重复了两遍，只是其中一个是对象属性的名称，另一个是为属性赋值的变量。</p><p>在ES6中，通过使用属性初始化的简写语法，可以消除这种属性名称与局部变量之间的重复书写。当一个对象的属性与本地变量同名时，不必再写冒号和值，简单地只写属性名即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">name,</span><br><span class="line">age</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当对象字面量里只有一个属性的名称时，JavaScript引擎会在可访问作用域中查找其同名变量；如果找到，则该变量的值被赋给对象字面量里的同名属性。<br><a id="more"></a></p><p><em>对象方法的简写语法</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"Nicholas"</span>,</span><br><span class="line">sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6中，对象方法消除了冒号和function关键字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name: <span class="string">"Nicholas"</span>,</span><br><span class="line">sayName() &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简写方法可以使用super关键字（后面介绍）。通过对象方法简写语法创建的方法有一个name属性，其值为小括号前的名称。</p><p><em>可计算属性名</em></p><p>在ES6中，可在对象字面量中使用可计算属性名称，其语法与引用对象实例的可计算属性名称相同，也是使用方括号。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastName = <span class="string">"last name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"><span class="string">"first name"</span>: <span class="string">"Nicholas"</span>,</span><br><span class="line">[lastName]: <span class="string">"Zakas"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person[lastName]); <span class="comment">//"Zakas"</span></span><br></pre></td></tr></table></figure></p><p><em>新增方法</em></p><p>Object.is()方法弥补全等运算符的不准确运算，该方法接受两个参数，如果这两个参数类型相同且具有相同的值，则返回true。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> == <span class="number">-0</span>);  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">//true</span></span><br><span class="line">coosole.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>,<span class="number">-0</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>Object.assign()方法可以接受任意数量的源对象，并按指定的顺序将属性复制到接收对象中。所以如果多个源对象具有同名属性，则排位靠后的源对象会覆盖排位靠前的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(receiver,</span><br><span class="line">&#123;</span><br><span class="line">type: <span class="string">"js"</span>,</span><br><span class="line">name: <span class="string">"file.js"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">type: <span class="string">"css"</span></span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(receiver.type);  <span class="comment">//"css"</span></span><br><span class="line"><span class="built_in">console</span>.log(receiver.name); <span class="comment">//"file.js"</span></span><br></pre></td></tr></table></figure></p><p>Object.assign()方法不能将提供者的访问器属性复制到接收对象中。由于Object.assign()方法执行了复制操作，因此提供者的访问器属性最终会转变为接收对象中的一个数据属性。</p><p><em>（扩展）数据属性与访问器属性</em></p><p>数据属性包含四个特性：</p><ul><li>configurable：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或能否把属性修改为访问器属性，默认为true</li><li>enumerable：表示能否通过for-in循环返回属性，默认为true</li><li>writable：表示能否修改属性的值，默认为true</li><li>value：包含该属性的数据值。默认为undefined</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">"mack"</span>,</span><br><span class="line">    cell: <span class="string">"1234"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">"name"</span>));</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span></span><br><span class="line">configurable: truee</span><br><span class="line">numerable: <span class="literal">true</span></span><br><span class="line">value: <span class="string">"mack"</span></span><br><span class="line">writable: <span class="literal">true</span></span><br><span class="line">__proto__: <span class="built_in">Object</span></span><br></pre></td></tr></table></figure><p>访问器属性包含的四个特性：</p><ul><li>configurable：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或能否把属性修改为访问器属性，默认为false</li><li>enumerable：表示能否通过for-in循环返回属性，默认为false</li><li>get：在读取属性时调用的函数，默认值为undefined</li><li>set：在写入属性时调用的函数，默认值为undefined</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">    _year: <span class="number">2017</span>, <span class="comment">//下划线表示是内部属性，只能通过对象的方法来读写</span></span><br><span class="line">    editor: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book,<span class="string">"year"</span>,&#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    set(newYear) &#123;</span><br><span class="line">        <span class="keyword">if</span>(newYear !== <span class="keyword">this</span>._year) &#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newYear;</span><br><span class="line">            editor++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(book,<span class="string">"year"</span>));</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configurable: <span class="literal">false</span></span><br><span class="line">enumerable: <span class="literal">false</span></span><br><span class="line">get: ƒ get()</span><br><span class="line">set: ƒ set(newYear)</span><br><span class="line">__proto__: <span class="built_in">Object</span></span><br></pre></td></tr></table></figure><p><em>重复的对象字面量属性</em></p><p>ES6移除了重复属性检查，无论是在严格模式还是非严格模式下，代码不再检查重复属性，对于每一组重复属性，都会选取最后一个取值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">name: <span class="string">"Nicholas"</span>,</span><br><span class="line">name: <span class="string">"Greg"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">//Greg</span></span><br></pre></td></tr></table></figure></p><p><em>自由属性枚举顺序</em></p><p>ES6严格规定了对象的自有属性被枚举时的返回顺序。基本规则如下：</p><ul><li>所有数字键按升序排序</li><li>所有字符串键按照它们被加入对象的顺序排序</li><li>所有symbol键按照它们被加入对象的顺序排序</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line"><span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">c: <span class="number">1</span>,</span><br><span class="line"><span class="number">2</span>: <span class="number">1</span>,</span><br><span class="line">b: <span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">obj.d = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj).join(<span class="string">""</span>)); <span class="comment">//"012acbd"</span></span><br></pre></td></tr></table></figure><p><em>增强对象原型</em></p><p>改变对象的原型：正常情况下，无论是通过构造函数还是Object.create()方法创建对象，其原型是在对象被创建时指定的，对象原型在实例化之后保持不变。在ES5中添加了Object.getPrototypeof()方法来返回任意指定对象的原型，ES6中添加了Object.setPrototypeOf()方法来改变任意指定对象的原型，它接受两个参数：被改变原型的对象及替代第一个参数原型的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">getGreeting() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">getGreeting() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Woof"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以person对象为原型</span></span><br><span class="line"><span class="keyword">let</span> friend = <span class="built_in">Object</span>.create(person); </span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">//Hello</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将原型设为dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend,dog);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">//Woof</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog); <span class="regexp">/true</span></span><br></pre></td></tr></table></figure></p><p>对象原型的真实值被储存在内部专用属性[[ Prototype ]]中，调用Object.getPrototypeOf()方法返回储存在其中的值，调用Object.setPrototypeOf()方法改变其中的值。</p><p>简化原型访问的Super引用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">getGreeting() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">getGreeting() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Woof"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">getGreeting() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">",hi"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将原型设置为person</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend,person);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">//Hello,hi</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将原型设为dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend,dog);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">//Woof,hi</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>在这个示例中，friend对象的getGreeting()方法调用了同名的原型方法。Object.getPrototypeOf()方法可以确保调用正确的原型，并向输出字符串叠加另一个字符串；后面的.call(this)可以确保正确设置原型方法中的this值。</p><p>ES6引入了super关键字。其引用相当于指向对象原型的指针，实际上也就是Object.getPrototypeOf(this)的值。必须要在使用简写方法的对象中使用super引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">getGreeting() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">getGreeting() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">",hi"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend,person);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> relative = <span class="built_in">Object</span>.create(friend);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.getGreeting()); <span class="comment">//Hello</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">//Hello,hi</span></span><br><span class="line"><span class="built_in">console</span>.log(relative.getGreeting()); <span class="comment">//Hello,hi</span></span><br></pre></td></tr></table></figure><p>super引用不是动态变化的，它总是指向正确的对象，在这个示例中，无论有多少其他方法继承了getGreeting方法，super.getGreeting()始终指向person.getGreeting()方法。</p><p>正式的方法定义：ES6中正式将方法定义为一个函数，它会有一个内部的[[ HomeObject ]]属性来容纳这个方法从属的对象。super的所有引用都通过[[ HomeObject ]]属性来确定后续的运行过程。第一步是在[[ HomeObject ]]属性上调用Object.getPrototypeOf()方法来检索原型的引用；然后搜寻原型找到同名函数；最后，设置this绑定并且调用相应的方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《深入理解ES6》笔记（一）</title>
      <link href="/2018/10/10/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/10/10/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>第3章 函数</strong></p><p><em>函数形参的默认值</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout = <span class="number">2000</span>, callback = function(</span>) </span>&#123;&#125;)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的其他部分</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，只有第一个参数被认为总是要为其传入值的，其它两个参数都有默认值，而且不需要添加任何校验值是否缺失的代码，所以函数体积会更加的小。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用参数timeout和参数callback的默认值</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用参数callback的默认值</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//不适用默认值</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="number">500</span>, <span class="function"><span class="keyword">function</span>(<span class="params">body</span>) </span>&#123;</span><br><span class="line">doSomething(body);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在ES6中，如果一个函数使用了默认参数值，则无论是否显式定义了严格模式，arguments对象的行为都将与ES5严格模式下保持一致。默认参数值的存在使得arguments对象保持与命名参数分离。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在非严格模式下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second = <span class="string">"b"</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//false</span></span><br><span class="line">    first = <span class="string">"c"</span>;</span><br><span class="line">    second = <span class="string">"d"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//false</span></span><br><span class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mixArgs(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><p>在这个示例中，只给mixArgs()方法传入一个参数，arguments.length的值为1，arguments[1]的值为undefined，first与arguments[0]全等，改变first和second并不会影响arguments对象。总是可以通过arguments对象将参数恢复为初始值，无论当前是否在严格模式的环境下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(</span>)) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">//7</span></span><br></pre></td></tr></table></figure><p>关于默认参数值，最有趣的特性可能是非原始值传参了。以上例子展示了可以通过函数执行来得到默认参数的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//let result = object.create(null);</span></span><br><span class="line">    <span class="keyword">let</span> result = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>,len = keys.length; i &lt; len; i++) &#123;</span><br><span class="line">        result[keys[i]] = object[keys[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">    title: <span class="string">"Understanding ECMAscript 6"</span>,</span><br><span class="line">    author: <span class="string">"Nicholas C. Zakas"</span>,</span><br><span class="line">    year: <span class="number">2016</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bookData = pick(book, <span class="string">"title"</span>,<span class="string">"author"</span>,<span class="string">"year"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bookData);</span><br></pre></td></tr></table></figure><p>无论函数已定义的命名参数有多少，都不限制调用时传入的实际参数数量，调用时总是可以传入任意数量的参数。处理不定参数时，可以在函数的命名参数钱添加三个点（…）就表明这是一个不定参数，该参数为一个数组，包含着自它之后传入的所有参数，通过这个数组名即可逐一访问里面的参数。它有两条使用限制，首先，每个函数最多只能声明一个不定参数，而且一定要放在所有参数的末尾。其次，它不能用于对象字面量setter中，之所以存在这条限制，是因为对象字面量setter的参数有且只能有一个。</p><p>如果声明函数时定义了不定参数，则在函数被调用时，arguments对象包含了所有传入函数的参数。</p><p><em>箭头函数</em></p><p>箭头函数与传统的JavaScript有些许的不同，主要集中在以下几个方面：</p><ul><li>没有this、super、arguments和new.target绑定：箭头函数中的this、super、arguments及new.target这些值由外围最近一层非箭头函数决定；</li><li>不能通过new关键字调用：箭头函数没有[[Construct]]方法，所以不能被用作构造函数；</li><li>没有原型，由于不可以通过new关键字调用箭头函数，因而没有构建原型的需求，所以箭头函数不存在prototype这个属性；</li><li>不可以改变this的绑定：函数内部的this值不可被改变，在函数的生命周期内始终保持一致；</li><li>不支持arguments对象：箭头函数没有arguments绑定，所以你必须通过命名参数和不定参数这两种形式访问函数的参数；</li><li>不支持重复的命名函数：无论是在严格模式还是在非严格模式下，箭头函数都不支持重复的命名参数。</li></ul><p>箭头函数的语法多变，根据实际的使用场景有多种形式。所有变种都由函数参数、箭头、函数体组成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reflect = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上相当于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reflect = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当箭头函数只有一个参数时，可以直接写参数名，箭头紧随其后，箭头右侧的表达式被求值后便立即返回。如果要传入两个或两个以上的参数，要在参数的两侧添加一对小括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上相当于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果想让箭头函数向外返回一个对象字面量，则需要将该字面量包裹在小括号内。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span> : id, <span class="attr">name</span> : <span class="string">"Temp"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上相当于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">id : id,</span><br><span class="line">name : <span class="string">"Temp"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《JavaScript语言精粹》笔记（一）</title>
      <link href="/2018/06/19/%E3%80%8AJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/06/19/%E3%80%8AJavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>第2章 语法</strong><br>数字<br>JavaScript只有一个数字类型。它在内部被表示为64位的浮点数，和java的double数字类型一样。与其他大多数编程语言不同的是，它没有分离出整数类型，所以1和1.0的值相同。</p><p>如果一个数字字面量有指数部分，那么这个字面量的值等于e之前的数字与10的e之后的数字的次方相乘。</p><p>NaN是一个数值，它表示一个不能产生正常结果的运算结果。NaN不等于任何值，包括它自己。可以用函数isNaN(number)检测NaN。<br><a id="more"></a><br>字符串<br>JavaScript在被创建的时候，Unicode是一个16位的字符集，所以JavaScript中的所有字符都是16位的。</p><p>JavaScript没有字符类型。要表示一个字符，只需创建仅包含一个字符的字符串即可。</p><p>\u约定用来指定数字字符编码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"A"</span> === <span class="string">"\u0041"</span></span><br></pre></td></tr></table></figure></p><p>两个包含着完全相同的字符且字符顺序也相同的字符串被认为是相同的字符串。</p><p>语句<br>一个编译单元包含一组可执行的语句。在web浏览器中，每个<code>&lt;script&gt;</code>标签提供一个被编译且立即执行的编译单元。因为缺少链接器，JavaScript把它们一起抛到一个公共的全局名字空间中。</p><p>当<code>var</code>语句被用在函数内部时，它定义的是这个函数的私有变量。</p><p>代码块是包在一对花括号中的一组语句，JavaScript中的代码块不会创建新的作用域，因此变量应该被定义在函数的头部，而不是在代码块中。（ES6引入块级作用域）</p><p>下列列出的值被当做假：</p><ul><li>false</li><li>null</li><li>undefined</li><li>空字符串’’</li><li>数字0</li><li>数字NaN</li></ul><p>其它均为真，包括true，字符串“false”，以及所有的对象。</p><p>try语句执行一个代码块，并捕获该代码块抛出的任何异常，catch从句定义一个新的变量来接收抛出的异常对象。throw语句抛出一个异常。如果throw语句在一个try代码块中，那么控制流会跳转到catch从句中。如果throw语句在函数中，则该函数调用被放弃，控制流跳转到调用该函数的try语句的catch从句中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).value;</span><br><span class="line">  <span class="keyword">if</span>(x==<span class="string">""</span>)    <span class="keyword">throw</span> <span class="string">"empty"</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">isNaN</span>(x)) <span class="keyword">throw</span> <span class="string">"not a number"</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&gt;<span class="number">10</span>)     <span class="keyword">throw</span> <span class="string">"too high"</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;<span class="number">5</span>)      <span class="keyword">throw</span> <span class="string">"too low"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">catch</span>(err)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">var</span> y=<span class="built_in">document</span>.getElementById(<span class="string">"mess"</span>);</span><br><span class="line">  y.innerHTML=<span class="string">"Error: "</span> + err + <span class="string">"."</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;h1&gt;My First JavaScript&lt;/</span>h1&gt;</span><br><span class="line">&lt;p&gt;Please input a number between <span class="number">5</span> and <span class="number">10</span>:&lt;/p&gt;</span><br><span class="line">&lt;input id=<span class="string">"demo"</span> type=<span class="string">"text"</span>&gt;</span><br><span class="line">&lt;button type=<span class="string">"button"</span> onclick=<span class="string">"myFunction()"</span>&gt;Test Input&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;p id="mess"&gt;&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure></p><p>return语句会导致从函数中提前返回。它可以指定要被返回的值，如果没有指定则默认为undefined。JavaScript不允许在return关键字和表达式之间换行。</p><p><strong>第3章</strong><br><em>对象</em><br>一个对象字面量就是包围在一对花括号中的零或多个“名/值”对。如果属性名是一个合法的JavaScript标识符且不是保留字，则并不强制要求用引号括住属性名。所以用括号括住如”first-name“是必需的（JavaScript的标识符中包含连接符‘-’是不合法的，但允许包含下划线），但是否括住”first_name“是可选的。</p><p>在检索对象里包含的值（属性值可以是出undefined值之外的任何值）时，||运算符可以用来填充默认值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> middle = stooge[<span class="string">"middle-name"</span>] || <span class="string">"(none)"</span>;</span><br><span class="line"><span class="keyword">var</span> status = flight.status || <span class="string">"unknown"</span>;</span><br></pre></td></tr></table></figure></p><p>检索一个并不存在的成员属性的值，将会返回undefined。尝试从undefined的成员属性中取值将会导致TypeError异常，这时可以通过&amp;&amp;运算符来避免错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flight.equipment <span class="comment">//undefined</span></span><br><span class="line">flight.equipment.model <span class="comment">//throw "TypeError"</span></span><br><span class="line">flight.equipment &amp;&amp; flight.equipment.model <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p><p>对象通过引用来传递，它们永远不会被复制。</p><p>每个对象都链接到一个原型对象，并且它可以从中继承属性。所有通过对象字面量创建的对象都链接到Object.prototype，它是JavaScript中的标配对象。</p><p>当创建一个新对象时，可以选择某个对象作为它的原型。原型链接只有在检索值的时候才被用到。如果我们尝试去获取对象的某个属性值，但该对象没有此属性名，那么JavaScript会试着从原型对象中获取属性值，如果那个原型对象也没有该属性，再从它的原型中寻找，以此类推，直到该过程最后到达终点Object.prototype。如果想要的属性完全不存在与原型链中，那么结果就是undefined。这个过程称为委托。</p><p>如果我们添加一个新的属性到原型中，该属性会立即对所有基于该原型创建的对象可见。</p><p>使用hasOwnProperty方法确定属性，如果对象拥有独有的属性，它将返回true。该方法不会检查原型链。</p><p>JavaScript可以很随意地定义全局变量来容纳应用的所有资源，遗憾地是，全局变量削弱了程序的灵活性，应该避免使用。最小化使用全局变量的方法之一是为应用创建一个唯一的全局变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</span><br><span class="line">MYAPP.stooge = &#123;</span><br><span class="line">  <span class="string">"first-name"</span>: <span class="string">"Joe"</span>,</span><br><span class="line">  <span class="string">"last0name"</span>: <span class="string">"Howard"</span></span><br><span class="line">&#125;;</span><br><span class="line">MYAPP.flight = &#123;</span><br><span class="line">  airline: <span class="string">"Oceanic"</span>,</span><br><span class="line">  number: <span class="number">815</span>,</span><br><span class="line">  departure: &#123;</span><br><span class="line">    IATA: <span class="string">"SYD"</span>,</span><br><span class="line">    time: <span class="string">"2004-09-22 14:55"</span></span><br><span class="line">    city: <span class="string">"Sydeny"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  arrival: &#123;</span><br><span class="line">    IATA: <span class="string">"LAX"</span>,</span><br><span class="line">    time: <span class="string">"2004-09-23 10:42"</span>,</span><br><span class="line">    city: <span class="string">"Los Angeles"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack+babel学习中遇到的一些问题（一）</title>
      <link href="/2018/06/08/webpack+babel%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/06/08/webpack+babel%E5%AD%A6%E4%B9%A0%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>webpack的一些配置</strong><br><strong>入口（entry）</strong><br>指示 webpack 应该使用哪个模块来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p><p>每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。<br><a id="more"></a><br><strong>出口（output）</strong><br>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry:&#123;      <span class="comment">// 这里应用程序开始执行</span></span><br><span class="line"> <span class="comment">// webpack 开始打包</span></span><br><span class="line">        main:__dirname+<span class="string">'/src/main.js'</span> <span class="comment">//入口</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">    <span class="comment">// webpack 如何输出结果的相关选项</span></span><br><span class="line">        filename:<span class="string">'bundle.js'</span>, <span class="comment">//输出的文件名</span></span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'build'</span>)   <span class="comment">// 所有输出文件的目标路径</span></span><br><span class="line">    <span class="comment">// 必须是绝对路径（使用 Node.js 的 path 模块）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目录结构如下图所示<br><img src="/assets/imgs/babel-01.png" alt="目录"></p><p>在执行npm run build的时候，终端提示“WARNING in configuration<br>The ‘mode’ option has not been set, webpack will fallback to ‘production’ for this value. Set ‘mode’ option to ‘development’ or ‘production’ to enable defaults for each environment.You can also set it to ‘none’ to disable any default behavior. Learn more: <a href="https://webpack.js.org/concepts/mode/”。" target="_blank" rel="noopener">https://webpack.js.org/concepts/mode/”。</a><br>该警告指的是没有设定是开发模式还是生产模式，要求指定。</p><p>在package.json中配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">   <span class="string">"build"</span>: <span class="string">"webpack --mode production"</span>,</span><br><span class="line">   <span class="string">"dev"</span>: <span class="string">"webpack --mode development"</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>此时警告消除，开发环境（development）输出的是未压缩文件，生产环境（production）输出的是压缩过的。</p><p><strong>babel的使用</strong><br><strong>安装</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-loader babel-core babel-preset-env</span><br></pre></td></tr></table></figure></p><p><strong>配置</strong><br>修改webpack.config.js，在module-rules下配置babel，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        main:__dirname+<span class="string">'/src/main.js'</span> <span class="comment">//入口</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">'bundle.js'</span>, <span class="comment">//输出的文件名</span></span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'build'</span>) <span class="comment">//输出文件所在的目录</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devServer:&#123; <span class="comment">//检测代码变化并自动重新编译并自动刷新浏览器</span></span><br><span class="line">        contentBase:path.resolve(__dirname,<span class="string">'build'</span>) <span class="comment">//设置静态资源的根目录</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123; <span class="comment">//这些选项决定了如何处理项目中的不同类型的模块</span></span><br><span class="line">        rules:[ <span class="comment">//创建模块时，匹配请求的规则数组。</span></span><br><span class="line">                <span class="comment">//这些规则能够修改模块的创建方式。</span></span><br><span class="line">                <span class="comment">//这些规则能够对模块(module)应用 loader，或者修改解析器(parser)。</span></span><br><span class="line">                <span class="comment">//每个规则可以分为三部分 - 条件(condition)，结果(result)和嵌套规则(nested rule)。</span></span><br><span class="line">                &#123;</span><br><span class="line">                    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                    use: &#123;</span><br><span class="line">                        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            presets: [<span class="string">'env'</span>]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    exclude: path.resolve(__dirname,<span class="string">'node_modules'</span>),</span><br><span class="line">                    include: path.resolve(__dirname,<span class="string">'src'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>重新打包npm run build生成bundle.js，此时查看bundle.js已经转成了ES5代码。</p><p>完整的package.json如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"01"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack --mode production"</span>,</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack --mode development"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"webpack-dev-server --open"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"keywords"</span>: [],</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"babel-core"</span>: <span class="string">"^6.26.3"</span>,</span><br><span class="line">    <span class="string">"babel-loader"</span>: <span class="string">"^7.1.4"</span>,</span><br><span class="line">    <span class="string">"babel-preset-env"</span>: <span class="string">"^1.7.0"</span>,</span><br><span class="line">    <span class="string">"webpack"</span>: <span class="string">"^4.11.1"</span>,</span><br><span class="line">    <span class="string">"webpack-cli"</span>: <span class="string">"^3.0.3"</span>,</span><br><span class="line">    <span class="string">"webpack-dev-server"</span>: <span class="string">"^3.1.4"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> babel </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue2学习过程中遇到的一些问题（一）</title>
      <link href="/2018/05/17/vue2%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/05/17/vue2%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h5 id="1-Elements-in-iteration-expect-to-have-‘v-bind-key’-directives"><a href="#1-Elements-in-iteration-expect-to-have-‘v-bind-key’-directives" class="headerlink" title="1. Elements in iteration expect to have ‘v-bind:key’ directives"></a>1. Elements in iteration expect to have ‘v-bind:key’ directives</h5><p>在用 v-for 指令根据一组数组的选项列表进行渲染时，VSCode提示“Elements in iteration expect to have ‘v-bind:key’ directives”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">"item in items"</span>&gt;</span><br><span class="line"> &lt;span&gt;&#123;&#123;item.text&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>li&gt;</span><br></pre></td></tr></table></figure><p>官方给出的解释是：当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的 track-by=”$index” 。</p><p>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。<br><a id="more"></a><br>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。这个特殊的属性相当于 Vue 1.x 的 track-by ，但它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值 (在这里使用简写)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">"item in items"</span> :key=<span class="string">"item.id"</span>&gt;</span><br><span class="line">  &lt;!-- 内容 --&gt;</span><br><span class="line">&lt;<span class="regexp">/li&gt;</span></span><br></pre></td></tr></table></figure><p>建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/15/hello-world/"/>
      <url>/2018/05/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> helloWrold </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
